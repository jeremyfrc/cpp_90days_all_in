# 基于SafeRegistry的三种并发模型

## 模型一：强一致 / 串行模型
（Single mutex + 锁内执行 fn）
### 核心特征
```cpp
with(h, fn) {
    lock(registry_mutex)
    check handle
    fn(buffer)   // 锁内执行
}
```
### 性质
| 维度    | 结果    |
| ----- | ----- |
| 一致性   | ⭐⭐⭐⭐⭐ |
| 实现复杂度 | ⭐     |
| 并发性能  | ⭐     |
| 死锁风险  | ⭐⭐⭐⭐  |

### 什么时候用
配置中心/控制面/管理后台
> QPS低
> fn短
> 正确性>性能
> 宁可慢，不可乱

*这是“我宁愿把世界锁住，也不让状态错”的模型*


## 模型二：生命周期安全 / 并发访问模型
（shared_ptr + 锁外执行）
### 核心特征
```cpp
with(h, fn) {
    shared_ptr buf;
    {
        lock(registry_mutex)
        buf = entry.buffer;  // 拷贝 shared_ptr
    }
    fn(*buf);  // 锁外执行
}
```
### 性质
| 维度     | 结果    |
| ------ | ----- |
| 一致性    | ⭐⭐⭐   |
| 并发性能   | ⭐⭐⭐⭐  |
| 生命周期安全 | ⭐⭐⭐⭐⭐ |
| 析构可控性  | ⭐⭐    |
### 什么时候用
监控/metrics/logging
> fn可能慢
> 并发高
> 延迟删除可以接受
> 不要求remove立即生效

*这是“宁愿晚死，也不能死错”的模型*


## 模型三：显式所有权 / Handle + Generation
（你现在写的 SafeRegistry）
### 核心特征
```cpp
with(h, fn) {
    lock
    validate id + gen
    fn(buffer)
}
```
### 性质
| 维度    | 结果    |
| ----- | ----- |
| 一致性   | ⭐⭐⭐⭐  |
| 性能    | ⭐⭐⭐   |
| 可预测性  | ⭐⭐⭐⭐⭐ |
| 实现复杂度 | ⭐⭐⭐⭐  |
### 什么时候用
核心系统 / 游戏引擎 / 内核组件
> handle是长期存在的
> 对“访问已销毁对象”零容忍
> 需要稳定 ID
> 可接受设计复杂度

这是“我必须知道你现在访问的是不是那个对象”的模型

